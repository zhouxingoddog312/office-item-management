#help information
function help()
{
	cat<<EOF
---------------------------------------------------------------------------------------------
物品管理系统（Office Item Management, OIM）- 使用帮助
Version: $VERSION
Author: zhouxin312
Contact: 1820034020@qq.com
---------------------------------------------------------------------------------------------
【功能说明】
1. 员工管理：添加/删除操作人员，用于记录操作归属
2. 物品种类管理：添加/删除物品，初始库存为0
3. 物品操作：入库（增加库存）、出库（减少库存，需库存充足）
4. 记录查询：按操作人员/物品名称/操作时间查询，或查看所有记录
5. 数据安全：退出自动增量备份、日志文件超10MB自动轮转

【依赖工具】
sed、gawk、zenity（图形界面）、python3、cups-client（打印功能）

【文件路径】
- 配置文件：$HOME/oim.config（用户） /usr/local/etc/oim/oim.config（系统）
- 工作目录：$WORK_DIR（含数据、日志、备份）
- 数据文件：$METADATA_DIR/item（物品库存）、$METADATA_DIR/employee（员工）、$METADATA_DIR/list（操作记录）

【使用方式】
1. 图形界面：应用菜单搜索 oim
2. 终端运行：直接输入命令 oim
---------------------------------------------------------------------------------------------
EOF
}
#version information
function version()
{
#用于调用时显示在命令行
	local version="$VERSION"
	cat<<EOF >&2
---------------------------------------------------------------------------------------------
Name: office item managements
Version: $version
Author: zhouxin312
contact:1820034020@qq.com
---------------------------------------------------------------------------------------------
EOF
#用于给变量赋值
	if ! [ -t 1 ]
	then
		echo "$version"
	fi
	return 0
}
#dependencies check
#通用依赖安装函数
#参数1：工具命令名（如sed、gawk、zenity，用于检查是否已安装）
#参数2：工具包名（通常与命令名相同，特殊情况可指定，如某些系统中包名可能不同）
function install_dependency(){
#命令名（用于检查是否已安装）
	local cmd_name="$1"
#包名，默认与命令名相同，可单独指定
	local pkg_name="${2:-$1}"
#检查工具是否已安装
	if command -v "$cmd_name" &>/dev/null
	then
		echo "$cmd_name工具已安装。"
		return 0
	fi
#检查sudo权限
	if ! sudo -v &>/dev/null
	then
		echo "错误：安装$cmd_name需要sudo权限，请以管理员身份运行脚本。"
		exit 1
	fi
	echo "脚本需要$cmd_name工具，开始安装..."
#根据包管理器安装
	if command -v apt &>/dev/null
	then
#Debian/Ubuntu 系列
		sudo apt update >/dev/null
		if sudo apt install -y "$pkg_name" &>/dev/null
		then
			echo "$cmd_name工具已通过apt安装。"
		else
			echo "错误：通过apt安装$cmd_name失败，请手动安装。"
		exit 1
		fi
	elif command -v dnf &>/dev/null
	then
#Fedora 系列
		if sudo dnf install -y "$pkg_name" &>/dev/null
		then
			echo "$cmd_name工具已通过dnf安装。"
		else
			echo "错误：通过dnf安装$cmd_name失败，请手动安装。"
			exit 1
		fi
	elif command -v yum &>/dev/null
	then
#CentOS/RedHat 系列
		if sudo yum install -y "$pkg_name" &>/dev/null
		then
			echo "$cmd_name工具已通过yum安装。"
		else
			echo "错误：通过yum安装$cmd_name失败，请手动安装。"
			exit 1
		fi
	else
		echo "未识别的包管理器，请手动安装$cmd_name工具。"
		exit 1
	fi
	return 0
}
#environment check
function check_dir()
{
	if [ ! -d "$1" ]
	then
		echo "目录$1不存在，创建该目录"
		if mkdir -p "$1"
		then
			echo "目录$1已创建"
		else
			echo "目录$1创建失败，请检查相关权限"
			exit 1
		fi
	fi
}
#employee file
#查看职工名单并支持快速删除/添加操作
function show_employee()
{
	local continue_show=true
	local selected_employee
	local exit_code
	local OLDIFS=$IFS
	while $continue_show
	do
#检查职工文件是否存在，不存在则创建
		[ -f "$EMPLOYEE_FILE" ] || touch "$EMPLOYEE_FILE"
#读取职工列表（用数组保存，支持含空格的姓名）
		mapfile -t employees < "$EMPLOYEE_FILE"
		local employee_count=${#employees[@]}
		if [ $employee_count -eq 0 ]
		then
			zenity --info --width=$WIDTH --height=$HEIGHT --title="无职工数据" --text="当前职工名单为空！" --ok-label="添加职工" --extra-button="返回" 2>/dev/null
			exit_code=$?
			if [ $exit_code -eq 0 ]
			then
				add_employee
			else
				continue_show=false
			fi
			continue
		fi
#显示职工列表（支持选择姓名，按钮：删除/取消/添加人员）
		IFS=$'\n'
		selected_employee=$(zenity --list --width=$WIDTH --height=$HEIGHT --title="职工名单（共$employee_count人）" --text="点击职工姓名可选择删除，或使用下方按钮操作：" --column="职工姓名" "${employees[@]}" --ok-label="删除选中" --cancel-label="取消" --extra-button="添加人员" 2>/dev/null)
		exit_code=$?
		IFS=$OLDIFS
#处理用户操作
		case $exit_code in
		0)
    			if [ -n "$selected_employee" ]
			then
        			del_employee "$selected_employee"
			else
				zenity --warning --width=$WIDTH --height=$HEIGHT --title="未选择" --text="请先点击选择要删除的职工" 2>/dev/null
			fi
			;;
#返回值1：优先判断是否点击“添加人员”按钮
		1)
    			if [ "$selected_employee" = "添加人员" ]
			then
				add_employee
			else
#否则执行“确认退出”逻辑
				zenity --question --width=$WIDTH --height=$HEIGHT --title="确认退出" --text="是否返回主菜单？" 2>/dev/null
				if [ $? -eq 0 ]
				then
					continue_show=false
				fi
			fi
			;;
		*)
			;;
		esac
	done
	echo "$(date +'%Y-%m-%d %H:%M:%S') - 退出职工名单浏览" >&8
	return 0
}
#此文件存储职工姓名，每行存储一个
#添加职工
function add_employee()
{
#循环是否继续的标记
	local continue_entry=true
	while $continue_entry
	do
#文件存在就输出职工名单，不存在就输出尚未录入
		if [ -f "$EMPLOYEE_FILE" ]
		then
			local existing_employees=$(cat "$EMPLOYEE_FILE"|sed 's/^/· /')
			local display_text="现有职工：\n$existing_employees\n\n请输入新职工姓名："
		else
			touch "$EMPLOYEE_FILE"
        		echo "$(date +'%Y-%m-%d %H:%M:%S') - 创建职工名单: $EMPLOYEE_FILE" >&8
			local display_text="尚未录入职工姓名，请添加第一位职工的姓名："
		fi
#显示职工名单并询问录入姓名
		new_employee=$(zenity --entry --width=$WIDTH --height=$HEIGHT --title="添加职工" --text="$display_text" --entry-text "" 2>/dev/null)
		if [ $? -ne 0 ]
		then
			zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消添加职工" 2>/dev/null
#取消录入就直接推出循环			
			break
		elif [ -z "$new_employee" ]
		then
			zenity --warning --width=$WIDTH --height=$HEIGHT --title="空值" --text="职工姓名不能为空" 2>/dev/null
			continue
#重复姓名的判断
		elif grep -q "^$new_employee$" "$EMPLOYEE_FILE"
		then
			zenity --warning --width=$WIDTH --height=$HEIGHT --title="重复" --text="该职工已添加，无需重复添加" 2>/dev/null
			continue
		fi
#将姓名存入指定文件
		echo "$new_employee" >> "$EMPLOYEE_FILE"
#添加日志
		echo "$(date +'%Y-%m-%d %H:%M:%S') - 添加员工: $new_employee" >&8
		existing_employees=$(cat "$EMPLOYEE_FILE"|sed 's/^/· /')
		display_text="现有职工：\n$existing_employees\n\n是否继续添加其他职工："
#显示现有职工名单并询问是否继续
		zenity --question --width=$WIDTH --height=$HEIGHT --ellipsize --title="继续添加" --text="$display_text" 2>/dev/null
		if [ $? -ne 0 ]
		then
			continue_entry=false
			zenity --info --width=$WIDTH --height=$HEIGHT --title="完成" --text="职工添加完毕" 2>/dev/null
		fi
	done
}
#删除职工
function del_employee()
{
#接收传入的职工姓名参数
	local target_employee="$1"
#判断是否继续删除
	local continue_del=true
#存储删除职工的姓名
	local selected
	local display_text
#文件不存在说明没有添加过职工
	if [ ! -f "$EMPLOYEE_FILE" ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="注意" --text="职工名单文件不存在，无法执行删除，请先添加职工名单。" 2>/dev/null
		return
	fi
#文件为空说明添加的职工已经删除完了
	if [ ! -s "$EMPLOYEE_FILE" ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="注意" --text="职工名单文件为空，无法执行删除，请先添加职工名单。" 2>/dev/null
		return
	fi
#若传入了职工姓名参数，直接处理（不进入循环）
	if [ -n "$target_employee" ]
	then
#验证参数中的职工是否存在
		if ! grep -q "^$target_employee$" "$EMPLOYEE_FILE"
		then
			zenity --error --width=$WIDTH --height=$HEIGHT --title="不存在" --text="职工 '$target_employee' 不存在，无法删除！" 2>/dev/null
			return 1
		fi
#执行删除（复用原删除逻辑，替换变量为target_emp）
		grep -v "^$target_employee$" "$EMPLOYEE_FILE" > "$EMPLOYEE_FILE.tmp"
#只要临时文件存在，就覆盖原文件（即使临时文件为空）
		if [ -f "$EMPLOYEE_FILE.tmp" ]
		then
			mv "$EMPLOYEE_FILE.tmp" "$EMPLOYEE_FILE"
#记录日志和提示
			echo "$(date +'%Y-%m-%d %H:%M:%S') - 删除职工: $target_employee" >&8
			zenity --info --width=$WIDTH --height=$HEIGHT --title="已删除" --text="职工'$target_employee'已成功删除。" 2>/dev/null
			return 0
		else
			zenity --error --width=$WIDTH --height=$HEIGHT --title="错误" --text="删除失败，无法生成临时文件！" 2>/dev/null
			return 1
		fi
	fi
	while $continue_del
	do
		selected=$(zenity --list --width=$WIDTH --height=$HEIGHT --title="删除职工" --text="请选择要删除的职工：" --column="职工姓名" $(cat "$EMPLOYEE_FILE") 2>/dev/null)
		if [ $? -ne 0 ]||[ -z "$selected" ]
		then
			zenity --info --width=$WIDTH --height=$HEIGHT --title="注意" --text="已取消删除操作" 2>/dev/null
			break
		fi
#反选未选择的职工姓名，使用临时文件记录，再覆盖原文件。下一次改为可同时删除多个职工。
		grep -v "^$selected$" "$EMPLOYEE_FILE" > "$EMPLOYEE_FILE.tmp"
#只要临时文件存在，就覆盖原文件（即使临时文件为空）
		if [ -f "$EMPLOYEE_FILE.tmp" ]
		then
			mv "$EMPLOYEE_FILE.tmp" "$EMPLOYEE_FILE"
#记录日志和提示
			echo "$(date +'%Y-%m-%d %H:%M:%S') - 删除职工: $selected" >&8
			zenity --info --width=$WIDTH --height=$HEIGHT --title="已删除" --text="职工'$selected'已成功删除。" 2>/dev/null
		else
			zenity --error --width=$WIDTH --height=$HEIGHT --title="错误" --text="删除失败，无法生成临时文件！" 2>/dev/null
		fi
		if [ ! -s "$EMPLOYEE_FILE" ]
		then
			zenity --info --width=$WIDTH --height=$HEIGHT --title="注意" --text="职工名单文件已为空，无法继续删除。" 2>/dev/null
			break
		fi
		display_text=$(cat "$EMPLOYEE_FILE")
		zenity --question --width=$WIDTH --height=$HEIGHT --title="继续删除" --text="当前职工名单：\n$display_text\n\n是否继续删除？" 2>/dev/null
		if [ $? -ne 0 ]
		then
			continue_del=false
			zenity --info --width=$WIDTH --height=$HEIGHT --title="完成" --text="删除操作已完成" 2>/dev/null
		fi
	done
}

#选择操作人，在记录中使用
#不存在EMPLOYEE_FILE说明没有添加过职工，返回2。
function select_employee()
{
	if [ ! -s "$EMPLOYEE_FILE" ]
	then
		zenity --error --width=$WIDTH --height=$HEIGHT --title="错误" --text="没有可选的操作人员，请先添加职工" 2>/dev/null
		return 2
	fi
	local selected=$(zenity --list --width=$WIDTH --height=$HEIGHT --title="选择操作人员" --text="请选择执行-$1-操作的职工：" --column="员工姓名" $(cat "$EMPLOYEE_FILE") 2>/dev/null)
	if [ $? -ne 0 ] || [ -z "$selected" ]
	then
		zenity --question --width=$WIDTH --height=$HEIGHT --title="警告：未选择操作人员" --text="必须选择操作人员-$1-操作才能继续！\n\n是否退出当前操作？\n- 【退出】：终止当前-$1-操作\n- 【继续】：返回重新选择员工" --ok-label="退出操作" --cancel-label="继续选择操作人员" 2>/dev/null
		local confirm_result=$?
		if [ $confirm_result -eq 0 ]
		then
			return 2
		else
			return 1
		fi
	fi
	echo "$selected"
	return 0
}
#选择操作时间，在记录中使用
function select_operation_time()
{
	local operation_type="$1"
	local default_date=$(date +'%Y-%m-%d')
	local default_time=$(date +'%H:%M:%S')
	local time_pattern='^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$'
	local selected_date
	local selected_time
	selected_date=$(zenity --calendar --width=$WIDTH --height=$HEIGHT --title="选择${operation_type}日期" --text="请选择${operation_type}操作的日期\n默认：${default_date}" --date-format="%Y-%m-%d" 2>/dev/null)
	if [ "$?" -ne 0 ]
	then
		return 1
	fi
	while true
	do
		selected_time=$(zenity --entry --width=$WIDTH --height=$HEIGHT --title="输入${operation_type}时间" --text="请输入${operation_type}操作的时间（格式：HH:MM:SS，24小时制）\n默认：${default_time}" --entry-text="$default_time" 2>/dev/null)
		if [ "$?" -ne 0 ]
		then
			return 1
		fi
		if [[ "$selected_time" =~ $time_pattern ]]
		then
			break
		else
			zenity --error --width=$WIDTH --height=$HEIGHT --title="格式错误" -text="时间格式不正确！请按HH:MM:SS输入（例如：$default_time）" 2>/dev/null
		fi
	done
	local full_time="${selected_date} ${selected_time}"
	echo "$full_time"
	return 0
}

#$LIST_FILE存储形式为：添加物品种类/删除物品种类/出库/入库/,物品种类名称,数量,操作人员,操作时间
#将向LIST_FILE写入信息的功能独立为一个函数，参数：操作类型 物品种类名称 数量 操作人员 操作时间 条目按操作时间的排列顺序（asc正序，desc逆序）
function log_to_list_file()
{
	local operate_type="$1"
	local item_name="$2"
	local quantity="$3"
	local operator="$4"
	local operation_time="$5"
#默认采用正序
	local sort_type="${6:-asc}"
	local log_entry="${operate_type},${item_name},${quantity},${operator},${operation_time}"
	local temp_file=$(mktemp)
#读取内容前，强制使用python将LIST_FILE文件指针移动回文件头部，确保能读取全部内容
	python3 -c 'import os;os.lseek(7,0,0)' 2>/dev/null
#读取描述符7中的所有历史记录（写入临时文件），此时文件指针到到文件末尾
	cat <&7 > "$temp_file"
#将新记录追加到临时文件
	echo "$log_entry" >> "$temp_file"
#在临时文件排序，默认正序
	if [ "$sort_type" = "desc" ]
	then
		sort -t',' -k5,5 -r "$temp_file" -o "$temp_file"
	else
		sort -t',' -k5,5  "$temp_file" -o "$temp_file"
	fi
#使用python将LIST_FILE文件指针移动回文件头部，以确保覆盖原有内容
	python3 -c 'import os;os.lseek(7,0,0)' 2>/dev/null
	cat "$temp_file" >&7

	rm -rf "$temp_file"
	echo "$(date +'%Y-%m-%d %H:%M:%S') - 日志记录完成（按${sort_type}排序）：$log_entry" >&8
	return 0
}
#item file存储形式为：物品名，数量
#添加条目，添加完成的条目库存数量为0
function add_item()
{
	local continue_add=true
	local existing_items
	local display_text
	local new_item
	local operator
	local operation_time
	while $continue_add
	do
#如果不存在物品记录文件，则创建该文件并记录
		if [ ! -f "$ITEM_FILE" ]
		then
        		touch "$ITEM_FILE"
        		echo "$(date +'%Y-%m-%d %H:%M:%S') - 创建条目文件: $ITEM_FILE" >&8
    		fi
#选择操作人，当EMPLOYEE_FILE不存在或为空时返回主界面，当选择取消时提示并继续选择
		operator=$(select_employee "添加物品种类")
		case "$?" in
			2) break
			;;
			1) continue
			;;
			*)
			;;
		esac
#如果物品记录文件不为空，则列出所有物品记录并询问添加物品，如果为空则直接询问
		if [ -s "$ITEM_FILE" ]
		then
			existing_items=$(awk -F',' '{print $1" - 库存数量："$2}' "$ITEM_FILE"|sed 's/^/· /')
			display_text="现有物品：\n$existing_items\n\n请输入需添加物品种类（初始库存为0）："
		else
			display_text="当前无任何物品，请输入第一个添加物品种类（初始库存为0）："
		fi
		new_item=$(zenity --entry --width=$WIDTH --height=$HEIGHT --title="添加物品种类" --text="$display_text" --entry-text="" 2>/dev/null)
#如果取消，直接返回主界面
		if [ $? -ne 0 ]
		then
			zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消物品种类添加，返回主界面" 2>/dev/null
			break
#如果物品种类名称为空，就重新输入物品种类名称
		elif [ -z "$new_item" ]
		then
			zenity --warning --width=$WIDTH --height=$HEIGHT --title="空值" --text="物品种类名称不能为空" 2>/dev/null
			continue
#如果物品种类名称与已录入的重复，则重新输入物品种类名称
		elif grep -q "^$new_item," "$ITEM_FILE"
		then
			zenity --error --width=$WIDTH --height=$HEIGHT --title="重复" --text="物品$new_item已存在，不可重复添加" 2>/dev/null
			continue
		fi
		echo "$new_item,0">>"$ITEM_FILE"
		operation_time=$(date +'%Y-%m-%d %H:%M:%S')
#向log文件中写入操作
		echo "$operation_time - 添加物品种类：$new_item；数量：0；操作人员：$operator" >&8
#向$LIST_FILE中写入操作
		log_to_list_file "添加物品种类" "$new_item" "0" "$operator" "$operation_time"
		zenity --info --width=$WIDTH --height=$HEIGHT --title="添加成功" --text="物品'$new_item'已添加（操作人员：$operator）" 2>/dev/null
		zenity --question --width=$WIDTH --height=$HEIGHT --title="继续" --text="是否继续添加物品种类？" 2>/dev/null
		if [ $? -ne 0 ]
		then
			continue_add=false
			zenity --info --width=$WIDTH --height=$HEIGHT --title="完成" --text="物品种类添加完成" 2>/dev/null
		fi
	done
}
#删除条目，删除条目时如果库存数不为0需要提醒并确认一次
function del_item()
{
	local continue_del=true
	local operator
	local operation_time
	local selected
	local item_name="$1"
	local item_count=0
#ITEM_FILE不存在或为空时，返回主界面
	if [ ! -f "$ITEM_FILE" ]||[ ! -s "$ITEM_FILE" ]
	then
		zenity --warning --width=$WIDTH --height=$HEIGHT --title="空列表" --text="未添加物品，无法删除。" 2>/dev/null
		return
	fi
	while $continue_del
	do
#选择对应的物品名称，返回形式为“名称 数量”
#如果未传入物品名称参数，则让用户选择
		if [ -z "$item_name" ]
		then
			selected=$(zenity --list --width=$WIDTH --height=$HEIGHT --print-column=ALL --separator="|" --title="删除物品种类" --text="请选择要删除的物品种类：" --column="物品名称" --column="当前数量" $(awk -F',' '{print $1" "$2}' "$ITEM_FILE")) 2>/dev/null
#判断返回值，取消则返回主界面
			if [ $? -ne 0 ]
			then
				zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="取消删除物品种类，返回主界面" 2>/dev/null
				break
			elif [ -z "$selected" ]
			then
				zenity --warning --width=$WIDTH --height=$HEIGHT --title="空值" --text="删除的物品名称不能为空" 2>/dev/null
				continue
			fi
#提取物品名称
			item_name=$(echo "$selected" | cut -d"|" -f1)
#提取物品数量
			item_count=$(echo "$selected" | cut -d"|" -f2)
#若通过参数传入，直接获取该物品的库存数量
		else
			item_count=$(awk -F',' -v name="$item_name" '$1 == name {print $2}' "$ITEM_FILE")
#验证物品是否存在
			if [ -z "$item_count" ]
			then
				zenity --error --width=$WIDTH --height=$HEIGHT --title="物品不存在" --text="物品种类 '$item_name' 不存在，无法删除！" 2>/dev/null
				break
			fi
		fi
#选择操作人，当EMPLOYEE_FILE不存在或为空时返回主界面，当选择取消时提示并继续选择
		operator=$(select_employee "删除物品种类")
		case "$?" in
			2) break
			;;
			1) continue
			;;
			*)
			;;
		esac
#库存非零时额外提醒
		if [ "$item_count" -ne 0 ]
		then
			zenity --question --width=$WIDTH --height=$HEIGHT --title="库存提醒" --text="物品种类 '$item_name' 当前库存为 $item_count，删除后数据将不可恢复！\n\n确认删除？" 2>/dev/null
			if [ $? -ne 0 ]
			then
#若通过参数调用，取消后直接退出
				[ -n "$1" ] && break
#否则重新选择物品
				item_name=""
				continue
			fi
		fi

#$item_name后面的逗号，防止物品名称部分匹配的情况
		grep -v "^$item_name," "$ITEM_FILE" > "$ITEM_FILE.tmp" && mv "$ITEM_FILE.tmp" "$ITEM_FILE"
		operation_time=$(date +'%Y-%m-%d %H:%M:%S')
		echo "$operation_time - 删除物品种类：$item_name；数量：$item_count；操作人员：$operator" >&8
#记录到LIST_FILE，格式：操作类型，物品名称，数量，操作人员，时间
		log_to_list_file "删除物品种类" "$item_name" "$item_count" "$operator" "$operation_time"
		zenity --info --width=$WIDTH --height=$HEIGHT --title="删除成功" --text="物品$item_name已删除（操作人员：$operator）" 2>/dev/null
#若通过参数调用，完成后直接退出
		if [ -n "$1" ]
		then
			break
		fi
#检查$ITEM_FILE是否为空，为空则返回主界面
		if [ ! -s "$ITEM_FILE" ]
		then
			zenity --warning --width=$WIDTH --height=$HEIGHT --title="空列表" --text="物品种类已全部删除，返回主界面" 2>/dev/null
			break
		fi
#询问是否继续删除
		zenity --question --width=$WIDTH --height=$HEIGHT --title="继续" --text="是否继续删除物品种类" 2>/dev/null
		if [ $? -ne 0 ]
		then
			zenity --info --width=$WIDTH --height=$HEIGHT --title="完成" --text="已完成删除物品种类,返回主界面" 2>/dev/null
			continue_del=false
		fi
#清空item_name，允许下次选择其他物品
		item_name=""
	done
}
#入库操作
function inbound()
{
	local continue_inbound=true
	local operator
	local operation_time
	local selected
	local item_name="$1"
	local current_count
	local add_count
	local new_count
	while "$continue_inbound"
	do
		if [ ! -f "$ITEM_FILE" ]||[ ! -s "$ITEM_FILE" ]
		then
			zenity --warning --width=$WIDTH --height=$HEIGHT --title="空列表" --text="未添加物品种类，无法入库。" 2>/dev/null
			return
		fi
#选择操作人，当EMPLOYEE_FILE不存在或为空时返回主界面，当选择取消时提示并继续选择
		operator=$(select_employee "入库")
		case "$?" in
			2) break
			;;
			1) continue
			;;
			*)
			;;
		esac
		if [ -z "$item_name" ]
		then
			selected=$(zenity --list --width=$WIDTH --height=$HEIGHT --title="入库" --text="请选择需要入库的物品：" --column="物品名称" --column="当前数量" --print-column=ALL --separator="|" $(awk -F',' '{print $1" "$2}' "$ITEM_FILE") 2>/dev/null)
#判断返回值，取消则返回主界面
			if [ "$?" -ne 0 ]
			then
				zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="取消入库操作，返回主界面" 2>/dev/null
				break
			elif [ -z "$selected" ]
			then
				zenity --warning --width=$WIDTH --height=$HEIGHT --title="空值" --text="入库的物品名称不能为空" 2>/dev/null
				continue
			fi
#提取物品名称
			item_name=$(echo "$selected" | cut -d'|' -f1)
		fi
#验证物品是否存在（无论是否通过参数传入）
		if ! grep -q "^$item_name," "$ITEM_FILE"
		then
			zenity --error --width=$WIDTH --height=$HEIGHT --title="物品不存在" --text="物品种类 '$item_name' 不存在，请检查！" 2>/dev/null
#如果是通过参数传入的无效物品，直接退出
			[ -n "$1" ] && break
#否则清空item_name，重新选择
			item_name=""
			continue
		fi
#获取当前库存数量
		current_count=$(awk -F',' -v name="$item_name" '$1 == name {print $2}' "$ITEM_FILE")
		add_count=$(zenity --entry --width=$WIDTH --height=$HEIGHT --title="入库数量" --text="物品：$item_name\n当前数量：$current_count\n请输入入库数量（正整数）：" --entry-text="1" 2>/dev/null)
		if [ "$?" -ne 0 ]
		then
#如果取消，直接返回主界面
			zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消入库操作，返回主界面" 2>/dev/null
			break
		elif [ -z "$add_count" ]
		then
#空值重新进行循环
			zenity --warning --width=$WIDTH --height=$HEIGHT --title="空值" --text="入库数量不能为空，重新输入" 2>/dev/null
			continue
		elif ! [[ "$add_count" =~ ^[1-9][0-9]*$ ]]
		then
#判断用户输入的数量是否是正整数，不是的话重新进行循环
			zenity --error --width=$WIDTH --height=$HEIGHT --title="错误的值" --text="$add_count不是有效的值，请输入正整数作为入库数量！" 2>/dev/null
			continue
		fi
		new_count=$((current_count + add_count))
#更新ITEM_FILE中与选定物品名称匹配的行，先写入临时文件，再用临时文件覆盖原文件
		awk -v name="$item_name" -v newcount="$new_count" -F',' '
			$1==name {print $1","newcount;next}
			{print}
		' "$ITEM_FILE">"$ITEM_FILE.tmp" && mv "$ITEM_FILE.tmp" "$ITEM_FILE"
#选择操作时间，用户取消日期或时间输入的话返回主界面
		operation_time=$(select_operation_time "入库")
		local time_result=$?
		if [ $time_result -eq 1 ]
		then
#用户取消日期或时间选择
			zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消入库操作，返回主界面" 2>/dev/null
			break
		fi
		echo "$operation_time - 入库：$item_name；数量：$add_count；操作人员：$operator" >&8
#记录到LIST_FILE，格式：操作类型，物品名称，数量，操作人员，时间
		log_to_list_file "入库" "$item_name" "$add_count" "$operator" "$operation_time"
		zenity --info --width=$WIDTH --height=$HEIGHT --title="完成" --text="物品入库成功！\n物品：$item_name\n入库数量：$add_count\n原库存：$current_count\n新库存：$new_count\n操作人：$operator\n时间：$operation_time" 2>/dev/null
#如果是通过参数调用（从库存列表进入），完成后直接退出，不询问继续
		if [ -n "$1" ]
		then
			break
		fi
#询问是否继续入库
		zenity --question --width=$WIDTH --height=$HEIGHT --title="继续" --text="是否继续入库" 2>/dev/null
		if [ $? -ne 0 ]
		then
			zenity --info --width=$WIDTH --height=$HEIGHT --title="完成" --text="已完成入库，返回主界面" 2>/dev/null
			continue_inbound=false
		fi
#清空item_name，允许下次选择其他物品
		item_name=""
	done
}
function outbound()
{
	local continue_outbound=true
	local operator
	local operation_time
	local selected
	local item_name="$1"
	local current_count
	local reduce_count
	local new_count
	while "$continue_outbound"
	do
		if [ ! -f "$ITEM_FILE" ]||[ ! -s "$ITEM_FILE" ]
		then
			zenity --warning --width=$WIDTH --height=$HEIGHT --title="空列表" --text="未添加物品种类，无法出库。" 2>/dev/null
			return
		fi
#选择操作人，当EMPLOYEE_FILE不存在或为空时返回主界面，当选择取消时提示并继续选择
		operator=$(select_employee "出库")
		case "$?" in
			2) break
			;;
			1) continue
			;;
			*)
			;;
		esac
#如果未传入物品名称参数，则让用户选择
		if [ -z "$item_name" ]
		then
			selected=$(zenity --list --width=$WIDTH --height=$HEIGHT --title="出库" --text="请选择需要出库的物品：" --column="物品名称" --column="当前数量" --print-column=ALL --separator="|" $(awk -F',' '{print $1" "$2}' "$ITEM_FILE") 2>/dev/null)
#判断返回值，取消则返回主界面
			if [ "$?" -ne 0 ]
			then
				zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="取消出库操作，返回主界面" 2>/dev/null
				break
			elif [ -z "$selected" ]
			then
				zenity --warning --width=$WIDTH --height=$HEIGHT --title="空值" --text="出库的物品名称不能为空" 2>/dev/null
				continue
			fi
			item_name=$(echo "$selected"|cut -d'|' -f1)
		fi
#验证物品是否存在
		if ! grep -q "^$item_name," "$ITEM_FILE"
		then
			zenity --error --width=$WIDTH --height=$HEIGHT --title="物品不存在" --text="物品种类 '$item_name' 不存在，请检查！" 2>/dev/null
#参数传入无效时退出
			[ -n "$1" ] && break
			item_name=""
			continue
		fi
#获取当前库存数量
		current_count=$(awk -F',' -v name="$item_name" '$1 == name {print $2}' "$ITEM_FILE")
#检查所选定的物品库存是否为零，如果为零则询问是否出库其他物品
		if [ "$current_count" -eq 0 ]
		then
			zenity --error --width=$WIDTH --height=$HEIGHT --title="库存不足" --text="物品$item_name当前库存为零，无法出库！" 2>/dev/null
#参数传入无效时退出
			[ -n "$1" ] && break
			if zenity --question --width=$WIDTH --height=$HEIGHT --title="重新选择" --text="是否重新选择其他物品出库？" 2>/dev/null
			then
				item_name=""
				continue
			else
				zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消出库操作，返回主界面" 2>/dev/null
				break
			fi
		fi
		local valid_quantity=false
		while [ "$valid_quantity" = false ]
		do
			reduce_count=$(zenity --entry --width=$WIDTH --height=$HEIGHT --title="出库数量" --text="物品：$item_name\n当前库存：$current_count\n请输入出库数量（正整数）：" --entry-text="1" 2>/dev/null)
#取消则返回主界面
			if [ "$?" -ne 0 ]
			then
				zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消出库操作，返回主界面" 2>/dev/null
				break 2
			fi
#空值检查
			if [ -z "$reduce_count" ]
			then
				zenity --warning --width=$WIDTH --height=$HEIGHT --title="空值" --text="出库数量不能为空，请重新输入" 2>/dev/null
#正整数检查（正则表达式）
			elif ! [[ "$reduce_count" =~ ^[1-9][0-9]*$ ]]
			then
				zenity --warning --width=$WIDTH --height=$HEIGHT --title="错误值" --text="$reduce_count不是有效的值，请输入正整数作为出库数量！" 2>/dev/null
#数量超库存检查
			elif [ "$reduce_count" -gt "$current_count" ]
			then
				zenity --warning --width=$WIDTH --height=$HEIGHT --title="数量超出" --text="出库数量$reduce_count大于当前库存$current_count，请重新输入！" 2>/dev/null
			else
				valid_quantity=true
			fi
		done
		new_count=$((current_count - reduce_count))
#更新ITEM_FILE中与选定物品名称匹配的行，先写入临时文件，再用临时文件覆盖原文件
		awk -v name="$item_name" -v newcount="$new_count" -F',' '
			$1==name {print $1","newcount;next}
			{print}
		' "$ITEM_FILE">"$ITEM_FILE.tmp" && mv "$ITEM_FILE.tmp" "$ITEM_FILE"
#选择操作时间，用户取消日期或时间输入的话返回主界面
		operation_time=$(select_operation_time "出库")
		local time_result=$?
		if [ $time_result -eq 1 ]
		then
#用户取消日期或时间选择
			zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消出库操作，返回主界面" 2>/dev/null
			break
		fi
		echo "$operation_time - 出库：$item_name；数量：$reduce_count；操作人员：$operator" >&8
#记录到LIST_FILE，格式：操作类型，物品名称，数量，操作人员，时间
		log_to_list_file "出库" "$item_name" "$reduce_count" "$operator" "$operation_time"
		zenity --info --width=$WIDTH --height=$HEIGHT --title="完成" --text="物品出库成功！\n物品：$item_name\n出库数量：$reduce_count\n原库存：$current_count\n新库存：$new_count\n操作人：$operator\n时间：$operation_time" 2>/dev/null
# 若通过参数调用，完成后直接退出
		if [ -n "$1" ]
		then
			break
		fi
#询问是否继续出库
		zenity --question --width=$WIDTH --height=$HEIGHT --title="继续" --text="是否继续出库" 2>/dev/null
		if [ $? -ne 0 ]
		then
			zenity --info --width=$WIDTH --height=$HEIGHT --title="完成" --text="已完成出库，返回主界面" 2>/dev/null
			continue_outbound=false
		fi
#清空item_name，允许下次选择其他物品
		item_name=""
	done
}
#查询函数，分别按物品、操作人员、时间展示操作记录
#主查询函数
function query_records()
{
	local query_type
	local results
#检查操作记录文件是否存在且非空	
	if [ ! -f "$LIST_FILE" ]||[ ! -s "$LIST_FILE" ]
	then
		zenity --warning --width=$WIDTH --height=$HEIGHT --title="无记录" --text="暂无操作记录可查询" 2>/dev/null
		return
	fi
	query_type=$(zenity --list --width=$WIDTH --height=$HEIGHT --title="查询方式" --text="请选择你想要的查询方式：" --column="查询方式" "按操作人员" "按物品名称" "按操作时间" "查看所有记录" 2>/dev/null)
#取消查询，返回主界面
	if [ "$?" -ne 0 ] || [ -z "$query_type" ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消查询操作，返回主界面" 2>/dev/null
		return
	fi
	case "$query_type" in
		"按操作人员")
			results=$(query_by_employee)
			;;
		"按物品名称")
			results=$(query_by_item)
			;;
		"按操作时间")
			results=$(query_by_optime)
			;;
		"查看所有记录")
			results=$(query_all_records)
			;;
		*)
			return
			;;
	esac
	display_results "$results"
}
#展示结果的函数
function display_results()
{
	local results="$1"
	local OLDIFS=$IFS
	local selected
	local exit_code
#无结果展示的情况
	if [ -z "$results" ] || [ "$results" = "1" ]
	then
		return
	elif [ -z "$(echo "$results" | tr -d '[:space:]')" ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="无结果" --text="未找到符合条件的结果" 2>/dev/null
		return
	fi
#展示查询结果表格，并在底部添加「打印」按钮
	IFS=$'|\n'
	selected=$(zenity --list  --width=$WIDTH --height=$HEIGHT --title="查询结果共$(echo "$results"|wc -l)条" --column="操作类型" --column="物品名称" --column="数量" --column="操作人员" --column="操作时间" --extra-button="打印" $results 2>/dev/null)
	exit_code="$?"
	IFS=$OLDIFS
#判断用户操作：点击「打印」按钮则触发打印
#当用户点击打印按钮时，selected会返回"打印"，且exit_code=0
	if [ "$exit_code" -eq 1 ] && [ "$selected" = "打印" ]
	then
		print_results "$results" "$WIDTH" "$HEIGHT"
	fi
}
#打印结果的函数
#打印结果函数（Python生成PDF版，无PS转换，彻底规避PS语法问题）
function print_results()
{
#传入的打印结果（|分隔）
	local results="$1"
#窗口宽度
	local width="$2"
#窗口高度
	local height="$3"
#临时PDF文件
	local temp_pdf=$(mktemp -t oim_print_XXXXXX.pdf)
#可用打印机列表
	local printer_list
#选中的打印机
	local selected_printer
#记录总数
	local total_lines=$(echo "$results" | wc -l)
#估算页数（每页30条记录）
	local total_pages=$(( (total_lines + 30) / 30 ))

#检查reportlab库是否安装（Python生成PDF的核心库）
	if ! python3 -c "import reportlab" 2>/dev/null
	then
    		zenity --warning --width="$width" --height="$height" --title="缺少Python库" --text="未安装reportlab（生成PDF必需），正在尝试自动安装...\n安装命令：sudo apt install python3-reportlab" 2>/dev/null
#自动安装reportlab（需要sudo权限）
		if ! sudo apt install -y python3-reportlab 2>/dev/null
		then
			zenity --error --width="$width" --height="$height" --title="安装失败" --text="自动安装失败，请手动执行：\nsudo apt install python3-reportlab" 2>/dev/null
			return 1
		fi
	fi
#选择打印机
	printer_list=$(lpstat -p 2>/dev/null | grep -v "disabled" | awk '{print $2}' | sort -u)
	if [ -z "$printer_list" ]
	then
		zenity --error --width="$width" --height="$height" --title="无可用打印机" --text="未检测到可用打印机，请检查：\n1. 打印机是否连接\n2. 启动CUPS服务：sudo systemctl start cups" 2>/dev/null
		rm -f "$temp_pdf"
		return 1
	fi
	selected_printer=$(echo "$printer_list" | zenity --list --width="$width" --height="$height" --title="选择打印机" --text="请选择打印设备（共$(echo "$printer_list" | wc -l)台）：" --column="可用打印机" 2>/dev/null)
	if [ $? -ne 0 ] || [ -z "$selected_printer" ]
	then
		zenity --info --width="$width" --height="$height" --title="取消打印" --text="已取消打印机选择，打印终止" 2>/dev/null
		rm -f "$temp_pdf"
		return 1
	fi
#Bash函数中嵌入Python代码（生成PDF）
#用Python的reportlab生成PDF，通过环境变量传递results
#将Bash变量results导出为环境变量，供Python读取
	export results
	python3 - <<EOF
		import os
		import time
		from reportlab.pdfgen import canvas
		from reportlab.lib.pagesizes import A4
		from reportlab.lib.units import mm
		from reportlab.pdfbase import pdfmetrics
		from reportlab.pdfbase.ttfonts import TTFont
#读取Bash传递的打印结果（环境变量）
		print_results = os.environ.get("results", "")
		if not print_results:
			exit(1)
#初始化PDF画布（A4尺寸：210mm×297mm）
		pdf_canvas = canvas.Canvas("$temp_pdf", pagesize=A4)
		page_width, page_height = A4
#注册中文字体（适配系统已有的中文字体）
		def register_chinese_font():
#系统中常见的中文字体路径（根据实际情况调整，优先文泉驿/Noto）
		font_paths = [
			"/usr/share/fonts/wqy-zenhei/wqy-zenhei.ttc",
			"/usr/share/fonts/google-noto-cjk-vf-fonts/NotoSerifCJK-VF.ttc",
			"/usr/share/fonts/truetype/simsun/simsun.ttc"
		]
		font_name = "ChineseFont"
		for font_path in font_paths:
			if os.path.exists(font_path):
				pdfmetrics.registerFont(TTFont(font_name, font_path))
				return font_name
#若未找到中文字体，返回默认字体（可能乱码，需提示用户）
			return "Helvetica"
#注册中文字体
		chinese_font = register_chinese_font()
#绘制PDF内容（标题、表头、记录）
def draw_pdf_content(canvas, content_lines):
    # 页面边距（20mm）
    left_margin = 20 * mm
    top_margin = 20 * mm
    line_spacing = 6  # 行间距（mm）
    current_y = page_height - top_margin  # 初始Y坐标（从顶部往下）

    # 1. 绘制标题
    canvas.setFont(chinese_font, 16)  # 标题字体大小16
    canvas.drawString(left_margin, current_y, "物品管理系统操作记录")
    current_y -= line_spacing * 2  # 标题下方留空

    # 2. 绘制查询信息（时间、记录数）
    canvas.setFont(chinese_font, 12)  # 信息字体大小12
    query_time = time.strftime("%Y-%m-%d %H:%M:%S")
    canvas.drawString(left_margin, current_y, f"查询时间：{query_time}")
    current_y -= line_spacing
    canvas.drawString(left_margin, current_y, f"记录总数：{len(content_lines)} 条")
    current_y -= line_spacing * 2

    # 3. 绘制表头（分隔线+表头文字）
    # 表头宽度分配（适配A4宽度）
    header_widths = [60, 60, 30, 60, 80]  # 操作类型|物品名称|数量|操作人员|操作时间（mm）
    header_texts = ["操作类型", "物品名称", "数量", "操作人员", "操作时间"]
    # 绘制表头分隔线
    canvas.line(left_margin, current_y, page_width - left_margin, current_y)
    current_y -= line_spacing
    # 绘制表头文字
    canvas.setFont(chinese_font, 11, bold=True)  # 表头字体加粗
    current_x = left_margin
    for i in range(len(header_texts)):
        canvas.drawString(current_x, current_y, header_texts[i])
        current_x += header_widths[i] * mm  # 按宽度分配表头位置
    current_y -= line_spacing
    # 绘制表头下方分隔线
    canvas.line(left_margin, current_y, page_width - left_margin, current_y)
    current_y -= line_spacing * 1.5

    # 4. 绘制每条记录（循环处理）
    canvas.setFont(chinese_font, 10)  # 记录字体大小10
    for line in content_lines:
        # 按|分割记录（与Bash传递的格式一致）
        parts = line.strip().split("|")
        if len(parts) != 5:
            continue  # 跳过格式错误的记录
        optype, item, qty, emp, op_time = parts

        # 检查是否需要分页（当前Y坐标低于下页边距）
        if current_y < 20 * mm:
            canvas.showPage()  # 新建页面
            current_y = page_height - top_margin  # 重置Y坐标
            # 新页面重新绘制表头
            canvas.setFont(chinese_font, 11, bold=True)
            current_x = left_margin
            for i in range(len(header_texts)):
                canvas.drawString(current_x, current_y, header_texts[i])
                current_x += header_widths[i] * mm
            current_y -= line_spacing
            canvas.line(left_margin, current_y, page_width - left_margin, current_y)
            current_y -= line_spacing * 1.5
            canvas.setFont(chinese_font, 10)  # 恢复记录字体

        # 绘制记录内容（按表头宽度分配位置）
        current_x = left_margin
        canvas.drawString(current_x, current_y, optype)
        current_x += header_widths[0] * mm
        canvas.drawString(current_x, current_y, item)
        current_x += header_widths[1] * mm
        canvas.drawString(current_x, current_y, qty)
        current_x += header_widths[2] * mm
        canvas.drawString(current_x, current_y, emp)
        current_x += header_widths[3] * mm
        canvas.drawString(current_x, current_y, op_time)
        current_y -= line_spacing

    # 绘制页脚（页码）
    canvas.showPage()
    canvas.save()

# 分割打印结果为行，调用绘制函数
result_lines = print_results.split("\\n")
draw_pdf_content(pdf_canvas, result_lines)

# 关闭画布
pdf_canvas.save()
EOF
#检查Python生成PDF是否成功
	if [ $? -ne 0 ] || [ ! -f "$temp_pdf" ] || [ $(stat -c "%s" "$temp_pdf") -lt 1024 ]
	then
		zenity --error --width="$width" --height="$height" --title="PDF生成失败" --text="Python生成PDF文件失败，请检查：\n1. 中文字体是否存在\n2. 打印结果是否有特殊字符（如# $ &）" 2>/dev/null
		rm -f "$temp_pdf"
		return 1
	fi
#发送PDF到打印机（兼容所有支持PDF的打印机）
	zenity --info --width="$width" --height="$height" --title="准备打印" --text="PDF文件已生成（共$total_pages页），即将发送到打印机「$selected_printer」" 2>/dev/null
#用lpr命令打印PDF（添加打印质量参数，适配不同打印机）
	if lpr -P "$selected_printer" -o media=A4 -o print-quality=600 -o sides=one-sided  "$temp_pdf" 2>/dev/null
	then
		zenity --info --width="$width" --height="$height" --title="打印成功" --text="已向打印机「$selected_printer」发送任务：\n- 纸张规格：A4（单面）\n- 打印质量：600dpi\n- 总页数：$total_pages\n- 格式：PDF（无PS转换，彻底规避语法问题）" 2>/dev/null
#降级参数（适配旧打印机）
	elif lpr -P "$selected_printer" -o media=A4 -o print-quality=300 "$temp_pdf" 2>/dev/null
	then
		zenity --info --width="$width" --height="$height" --title="打印成功（兼容模式）" --text="已用兼容模式发送任务（适配旧打印机）：\n- 纸张：A4\n- 质量：300dpi\n- 页数：$total_pages" 2>/dev/null
	else
#打印失败：提示手动打印
		zenity --error --width="$width" --height="$height" --title="打印失败" --text="自动打印失败，请手动打开以下文件打印：\n$temp_pdf" 2>/dev/null
		rm -f "$temp_pdf"
		return 1
        fi
#清理临时文件（避免残留）
	rm -f "$temp_pdf"
	return 0
}
#按操作人员查询的子函数
function query_by_employee()
{
	local employee_list
	local selected_employee
#获取操作人员列表并去重
	employee_list=$(awk -F',' '{print $4}' "$LIST_FILE"|sort|uniq)
#如果没有提取到操作人员数据，就返回1
	if [ -z "$employee_list" ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="无数据" --text="无操作人员数据" 2>/dev/null
		return 1
	fi
	selected_employee=$(zenity --list --width=$WIDTH --height=$HEIGHT --title="选择操作人员" --text="请选择要查询的操作人员：" --column="操作人员" $employee_list 2>/dev/null)
	if [ "$?" -ne 0 ] || [ -z "$selected_employee" ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消查询" 2>/dev/null
		return 1
	fi
#筛选出选定操作人员的记录行，并输出
	awk -F',' -v employee="$selected_employee" '
		$4 == employee {print $1"|"$2"|"$3"|"$4"|"$5}
	' "$LIST_FILE"
	return 0
}
#按物品名称查询的子函数
function query_by_item()
{
	local item_list
	local selected_item
#获取物品名称列表并去重
	item_list=$(awk -F',' '{print $2}' "$LIST_FILE"|sort|uniq)
#如果没有提取到物品名称数据，就返回1
	if [ -z "$item_list" ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="无数据" --text="无物品名称数据" 2>/dev/null
		return 1
	fi
	selected_item=$(zenity --list --width=$WIDTH --height=$HEIGHT --title="选择物品名称" --text="请选择要查询的物品名称：" --column="物品名称" $item_list 2>/dev/null)
	if [ "$?" -ne 0 ] || [ -z "$selected_item" ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消查询" 2>/dev/null
		return 1
	fi
#筛选出选定物品名称的记录行，并输出
	awk -F',' -v item="$selected_item" '
		$2 == item {print $1"|"$2"|"$3"|"$4"|"$5}
	' "$LIST_FILE"
	return 0
}
#按操作时间查询的子函数
function query_by_optime()
{
#查询的开始时间
	local start_full_time
#查询的结束时间
	local end_full_time
#开始时间转换为时间戳
	local start_time_stamp
#结束时间转换为时间戳
	local end_time_stamp
#select_operation_time的退出码
	local exit_code
#获取开始时间
	echo "正在选择查询的开始时间..." >&8
	start_full_time=$(select_operation_time "开始")
	exit_code=$?
	if [ "$exit_code" -eq 1 ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消开始时间选择，终止查询" 2>/dev/null
		return 1
	fi
#获取结束时间
	echo "正在选择查询的结束时间..." >&8
	end_full_time=$(select_operation_time "结束")
	exit_code=$?
	if [ "$exit_code" -eq 1 ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="取消" --text="已取消结束时间选择，终止查询" 2>/dev/null
		return 1
	fi
#转换为对应的时间戳
	start_time_stamp=$(date -d "$start_full_time" +%s 2>/dev/null)
	end_time_stamp=$(date -d "$end_full_time" +%s 2>/dev/null)
	if [ -z "$start_time_stamp" ] || [ -z "$end_time_stamp" ] || [ "$start_time_stamp" -gt "$end_time_stamp" ]
	then
		zenity --error --width=$WIDTH --height=$HEIGHT --title="时间无效" --text="开始时间必须早于或等于结束时间！\n开始时间：$start_full_time\n结束时间：$end_full_time" 2>/dev/null
		return 1
	fi
#筛选时间范围内的记录
	echo "$(date +'%Y-%m-%d %H:%M:%S') - 筛选时间范围记录：$start_full_time 至 $end_full_time" >&8
	awk -F',' -v start="$start_time_stamp" -v end="$end_time_stamp" '
	{
		record_time_stamp=mktime(gensub(/[-:]/," ","g",$5))
		if(record_time_stamp>=start && record_time_stamp<=end)
		{
			print $1"|"$2"|"$3"|"$4"|"$5
		}
	}
	' "$LIST_FILE"
	return 0
}
function query_all_records()
{
#直接读取LIST_FILE所有内容，按格式转换为|分隔
#LIST_FILE格式：操作类型,物品名称,数量,操作人员,操作时间
	awk -F',' '{print $1"|"$2"|"$3"|"$4"|"$5}' "$LIST_FILE"
	return 0
}
#初始化启动备份（仅在软件启动时执行）
function init_startup_backup()
{
#启动备份文件路径（放在BACKUP_DIR下，与退出备份区分，命名加.startup前缀）
	local startup_backups=("$BACKUP_DIR/employee.startup.bak" "$BACKUP_DIR/item.startup.bak" "$BACKUP_DIR/list.startup.bak")
#原数据文件路径（从配置文件读取）
	local src_files=("$EMPLOYEE_FILE" "$ITEM_FILE" "$LIST_FILE")
#为每个数据文件创建启动时备份（仅首次启动时生成）
	for i in "${!src_files[@]}"
	do
		local src_file="${src_files[$i]}"
		local backup_file="${startup_backups[$i]}"
#若备份文件不存在，则创建（确保保留启动时的初始状态）
		if [ ! -f "$backup_file" ]
		then
#原文件存在则备份，不存在则创建空文件后备份
			[ -f "$src_file" ] || touch "$src_file"
			cp "$src_file" "$backup_file"
			echo "$(date +'%Y-%m-%d %H:%M:%S') - 生成启动备份：$src_file -> $backup_file" >&8
		fi
	done
}
#回撤函数：恢复到本次启动时的初始状态（路径适配配置文件）
function rollback_operations()
{
#启动备份与原文件的对应关系（严格对应配置文件路径）
	local backup_mapping=("$BACKUP_DIR/employee.startup.bak:$EMPLOYEE_FILE" "$BACKUP_DIR/item.startup.bak:$ITEM_FILE" "$BACKUP_DIR/list.startup.bak:$LIST_FILE")
#检查所有启动备份是否齐全
	local missing=0
	for pair in "${backup_mapping[@]}"
	do
		local backup_file=$(echo "$pair" | cut -d':' -f1)
		if [ ! -f "$backup_file" ]
		then
			zenity --error --width=$WIDTH --height=$HEIGHT --title="备份缺失" --text="缺少启动备份文件：$backup_file\n无法执行回撤操作" 2>/dev/null
			missing=1
			break
		fi
	done
	if [ $missing -eq 1 ]
	then
		return 1
	fi
#二次确认用户操作（防止误触）
	zenity --question --width=$WIDTH --height=$HEIGHT --title="确认回撤" --text="确定要回撤本次打开软件后的所有操作吗？\n（将恢复到启动时的初始状态，不可逆！）" --ok-label="确认回撤" --cancel-label="取消" 2>/dev/null
	if [ $? -ne 0 ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="已取消" --text="回撤操作已取消" 2>/dev/null
		return 0
	fi
#执行回撤：用启动备份覆盖当前文件
	local success=1
	for pair in "${backup_mapping[@]}"
	do
		local backup_file=$(echo "$pair" | cut -d':' -f1)
		local target_file=$(echo "$pair" | cut -d':' -f2)
		if ! cp "$backup_file" "$target_file"
		then
			zenity --error --width=$WIDTH --height=$HEIGHT --title="回撤失败" --text="无法覆盖文件：$target_file" 2>/dev/null
			success=0
			break
		fi
		echo "$(date +'%Y-%m-%d %H:%M:%S') - 回撤文件：$backup_file -> $target_file" >&8
	done
#反馈结果并刷新界面
	if [ $success -eq 1 ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="回撤成功" --text="所有操作已回撤至本次启动时的状态！" 2>/dev/null
#刷新库存显示（若在库存页面）
		if declare -f show_inventory &>/dev/null
		then
			show_inventory
		fi
	fi
}
#用于备份的函数
function backup()
{
	local backup_pairs=("$EMPLOYEE_FILE:$EMPLOYEE_FILE_BACKUP" "$ITEM_FILE:$ITEM_FILE_BACKUP" "$LIST_FILE:$LIST_FILE_BACKUP")
	echo "$(date +'%Y-%m-%d %H:%M:%S') - 开始执行退出备份..." >&8
	for pair in "${backup_pairs[@]}"
	do
		local src_file=$(echo "$pair"|cut -d':' -f1)
		local backup_file=$(echo "$pair"|cut -d':' -f2)
		if [ -f "$src_file" ] && [ -s "$src_file" ]
		then
			cp "$src_file" "$backup_file"
			if [ "$?" -eq 0 ]
			then
				echo "$(date +'%Y-%m-%d %H:%M:%S') - 备份成功：$src_file -> $backup_file" >&8
			else
				echo "$(date +'%Y-%m-%d %H:%M:%S') - 警告：备份失败（$src_file -> $backup_file）" >&8
			fi
		else
			echo "$(date +'%Y-%m-%d %H:%M:%S') - 跳过备份：$src_file 不存在或为空" >&8
		fi
	done
	echo "$(date +'%Y-%m-%d %H:%M:%S') - 退出备份完成" >&8
#备份完成后关闭文件描述符（确保日志可写入）
	exec 7>&-
	exec 8>&-
}
#按log文件的大小备份
#当日志文件达到指定大小阈值时，自动备份并清空原日志
function log_rotate()
{
	local log_file="$LOG"
	local backup_dir="$BACKUP_DIR"
#大小阈值（10MB，可修改，单位：字节）
	local size_threshold=$((10 * 1024 * 1024))
	local timestamp=$(date +'%Y%m%d_%H%M%S')
	local backup_file="$backup_dir/$(basename "$log_file").$timestamp"
#确保备份目录存在
	check_dir "$backup_dir"
#若日志文件不存在，直接返回
	if [ ! -f "$log_file" ]
	then
		return 0
	fi
#获取当前日志文件大小（字节）
	if command -v stat &>/dev/null
	then
		local current_size=$(stat -c "%s" "$log_file" 2>/dev/null)
	fi
#若获取大小失败（如权限问题），返回
	if [ -z "$current_size" ] || [ "$current_size" -lt 0 ]
	then
		return 0
	fi
#仅当日志大小超过阈值且非空时，触发备份
	if [ "$current_size" -ge "$size_threshold" ] && [ "$current_size" -gt 0 ]
	then
#执行备份
		cp "$log_file" "$backup_file"
		if [ $? -eq 0 ]
		then
#备份成功后，清空原日志（保留文件句柄，避免后续写入失败）
			> "$log_file"
#记录备份信息到日志
			echo "$(date +'%Y-%m-%d %H:%M:%S') - 日志达到大小阈值（${size_threshold}/1024KB），备份完成：$log_file -> $backup_file（实际大小：$((current_size/1024))KB）" >&8
		else
			echo "$(date +'%Y-%m-%d %H:%M:%S') - 警告：日志备份失败（$log_file -> $backup_file）" >&8
		fi
	fi
}

#展示所有物品库存，并支持选中后操作
function show_inventory()
{
	local continue_show=true
	local selected_item
	local item_name
	local item_count
	local action
	local exit_code
	local OLDIFS=$IFS
	while $continue_show
	do
#检查ITEM_FILE物品文件是否存在且非空
		if [ ! -f "$ITEM_FILE" ] || [ ! -s "$ITEM_FILE" ]
		then
			zenity --info --width=$WIDTH --height=$HEIGHT --title="无库存数据" --text="当前无任何物品种类记录！" --ok-label="添加物品种类" --extra-button="返回主菜单" 2>/dev/null
			exit_code=$?
			if [ "$exit_code" -eq 0 ]
			then
				add_item
			else
				continue_show=false
			fi
			continue
		fi
#读取库存数据并格式化
		local inventory_data=$(awk -F',' '{print $1"|"$2}' "$ITEM_FILE")
		IFS=$'|\n'
		selected_item=$(zenity --list --width=$WIDTH --height=$HEIGHT --title="物品库存列表" --text="请选择物品种类进行操作，或点击【添加物品种类】新增：" --column="物品种类" --column="当前库存" --ok-label="选择操作" --extra-button="添加物品种类" --print-column=ALL $inventory_data 2>/dev/null)
#捕获退出码：0=选择操作；selected_item=添加物品种类 exit_code=1；1=关闭窗口/取消
		exit_code=$?
		IFS=$OLDIFS
#处理退出逻辑
#处理选中物品或添加物品种类
		if [ "$exit_code" -eq 0 ]
		then
			item_name=$(echo "$selected_item" | cut -d'|' -f1)
			item_count=$(echo "$selected_item" | cut -d'|' -f2)
#选择操作类型
			action=$(zenity --list --width=$WIDTH --height=$HEIGHT --title="操作选择" --text="物品种类：$item_name（当前库存：$item_count）\n请选择操作类型：" --column="操作" "入库" "出库" "删除物品种类" 2>/dev/null)
			case "$action" in
			"入库")
				echo "$(date +'%Y-%m-%d %H:%M:%S') - 从库存列表选择【入库】：$item_name" >&8
				inbound "$item_name"
				;;
			"出库")
				echo "$(date +'%Y-%m-%d %H:%M:%S') - 从库存列表选择【出库】：$item_name" >&8
				outbound "$item_name"
				;;
			"删除物品种类")
				echo "$(date +'%Y-%m-%d %H:%M:%S') - 从库存列表选择【删除物品种类】：$item_name" >&8
				del_item "$item_name"
				;;
			*)
				zenity --info --width=$WIDTH --height=$HEIGHT --title="取消操作" --text="未选择操作，返回库存列表" 2>/dev/null
				;;
			esac
		elif [ "$selected_item" = "添加物品种类" ]
		then
			add_item
		else
			zenity --question --width=$WIDTH --height=$HEIGHT --title="确认返回" --text="是否返回主菜单？" 2>/dev/null
			if [ $? -eq 0 ]
			then
				continue_show=false
			fi
			continue
		fi
	done
}
#导出数据函数：将3个核心数据文件打包为tar.gz（支持自定义保存位置）
function export_data()
{
	local data_files=("$ITEM_FILE" "$EMPLOYEE_FILE" "$LIST_FILE")
	local data_names=("物品库存文件" "员工文件" "操作记录文件")
	local missing=0
	local missing_files=""
#让用户选择压缩包保存位置（默认路径：BACKUP_DIR/数据导出_时间戳.tar.gz）
	local default_filename="数据导出_$(date +'%Y%m%d_%H%M%S').tar.gz"
	local default_path="$BACKUP_DIR/$default_filename"
#检查数据文件是否存在且非空
	for i in "${!data_files[@]}"
	do
		local file="${data_files[$i]}"
		local name="${data_names[$i]}"
		if [ ! -f "$file" ]
		then
			missing=1
			missing_files+="• $name：$file（文件不存在）\n"
		elif [ ! -s "$file" ]
		then
#允许空文件导出（避免新系统无数据时无法打包）
		zenity --warning --width=$WIDTH --height=$HEIGHT --title="文件为空" --text="$name（$file）内容为空，仍将纳入打包" 2>/dev/null
		fi
	done
#若关键文件缺失，终止导出
	if [ $missing -eq 1 ]
	then
		zenity --error --width=$WIDTH --height=$HEIGHT --title="导出失败" --text="以下核心文件缺失，无法导出：\n$missing_files" 2>/dev/null
		return 1
	fi
#用zenity选择保存位置（支持自定义路径和文件名）
	export_path=$(zenity --file-selection --width=$WIDTH --height=$HEIGHT --title="选择导出压缩包保存位置" --save --filename="$default_path" --file-filter="Tar GZ (*.tar.gz)" 2>/dev/null)
#用户取消选择
	if [ $? -ne 0 ] || [ -z "$export_path" ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="取消导出" --text="已取消数据导出操作" 2>/dev/null
		return 0
	fi
#执行打包（tar.gz格式，保留文件路径结构）
	zenity --info --width=$WIDTH --height=$HEIGHT --title="开始导出" --text="即将导出以下文件到压缩包：\n• ${data_files[0]}\n• ${data_files[1]}\n• ${data_files[2]}\n\n保存路径：$export_path" 2>/dev/null
#执行tar打包（-C 指定METADATA_DIR为根目录，避免打包完整绝对路径）
	if ! tar -zcvf "$export_path" -C "$METADATA_DIR" "$(basename "$ITEM_FILE")" "$(basename "$EMPLOYEE_FILE")" "$(basename "$LIST_FILE")" 2>/dev/null
	then
		zenity --error --width=$WIDTH --height=$HEIGHT --title="打包失败" --text="压缩包生成失败，请检查：\n1. 保存路径是否有写入权限\n2. 数据文件是否被其他程序占用" 2>/dev/null
#删除损坏的压缩包
		rm -f "$export_path"
		return 1
	fi
#导出成功提示
	zenity --info --width=$WIDTH --height=$HEIGHT --title="导出成功" --text="数据导出打包完成！\n• 压缩包路径：$export_path\n• 包含文件：3个核心数据文件\n• 格式：tar.gz（可手动解压查看）" 2>/dev/null
	echo "$(date +'%Y-%m-%d %H:%M:%S') - 数据导出成功：$export_path" >&8
	return 0
}
#导入数据函数：解压tar.gz压缩包，覆盖现有3个数据文件（不可逆）
function import_data()
{
#定义需要导入的目标文件
	local target_files=("$ITEM_FILE" "$EMPLOYEE_FILE" "$LIST_FILE")
	local target_names=("物品库存文件" "员工文件" "操作记录文件")
#临时解压目录
	local temp_dir=$(mktemp -d -t oim_import_XXXXXX)
#用于检查压缩包里的三个文件是否存在
	local required_files=("$(basename "$ITEM_FILE")" "$(basename "$EMPLOYEE_FILE")" "$(basename "$LIST_FILE")")
#标记有文件缺失
	local missing_in_tar=0
#记录缺失的文件名
	local missing_files=""
#用于标记覆盖是否成功，1成功，0失败
	local success=1
#让用户选择导入的tar.gz压缩包
	import_path=$(zenity --file-selection --width=$WIDTH --height=$HEIGHT --title="选择导入的压缩包" --file-filter="*.tar.gz" 2>/dev/null)
#用户取消选择
	if [ $? -ne 0 ] || [ -z "$import_path" ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="取消导入" --text="已取消数据导入操作" 2>/dev/null
		rm -rf "$temp_dir"
		return 0
	fi
#检查压缩包是否存在
	if [ ! -f "$import_path" ]
	then
		zenity --error --width=$WIDTH --height=$HEIGHT --title="文件不存在" --text="选择的压缩包不存在：$import_path" 2>/dev/null
		rm -rf "$temp_dir"
		return 1
	fi
#验证压缩包完整性和包含的文件
#检查压缩包是否损坏
	if ! tar -ztf "$import_path" 2>/dev/null
	then
		zenity --error --width=$WIDTH --height=$HEIGHT --title="压缩包损坏" --text="选择的tar.gz文件损坏或格式错误，无法导入" 2>/dev/null
		rm -rf "$temp_dir"
		return 1
	fi
#检查压缩包是否包含3个必需文件
	for file in "${required_files[@]}"
	do
		if ! tar -ztf "$import_path" | grep -q "^$file$"
		then
			missing_in_tar=1
			missing_files+="• $file\n"
		fi
	done
	if [ $missing_in_tar -eq 1 ]
	then
		zenity --error --width=$WIDTH --height=$HEIGHT --title="压缩包内容无效" --text="压缩包中缺少以下必需文件，无法导入：\n$missing_files\n请选择正确的导出压缩包" 2>/dev/null
		rm -rf "$temp_dir"
		return 1
	fi
#警告用户：导入将覆盖现有数据（不可逆）
	zenity --question --width=$WIDTH --height=$HEIGHT --title="警告：不可逆操作" --text="确认导入以下压缩包？\n导入后将覆盖现有所有数据（无法恢复）！\n\n压缩包路径：$import_path\n\n包含文件：\n• ${target_names[0]}\n• ${target_names[1]}\n• ${target_names[2]}" --ok-label="确认覆盖" --cancel-label="取消" 2>/dev/null
	if [ $? -ne 0 ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="取消覆盖" --text="已取消数据覆盖操作" 2>/dev/null
		rm -rf "$temp_dir"
		return 0
	fi
#解压压缩包并覆盖现有文件
#先解压到临时目录（避免直接覆盖出错）
	if ! tar -zxvf "$import_path" -C "$temp_dir" 2>/dev/null
	then
		zenity --error --width=$WIDTH --height=$HEIGHT --title="解压失败" --text="压缩包解压失败，请检查权限" 2>/dev/null
		rm -rf "$temp_dir"
		return 1
	fi
#覆盖每个目标文件
	for i in "${!target_files[@]}"
	do
		local temp_file="$temp_dir/$(basename "${target_files[$i]}")"
		local target_file="${target_files[$i]}"
		local target_name="${target_names[$i]}"
#执行覆盖
		if ! mv -f "$temp_file" "$target_file"
		then
			zenity --error --width=$WIDTH --height=$HEIGHT --title="覆盖失败" --text="$target_name（$target_file）覆盖失败，请检查写入权限" 2>/dev/null
			success=0
			break
		fi
		echo "$(date +'%Y-%m-%d %H:%M:%S') - 导入覆盖：$temp_file -> $target_file" >&8  # 记录日志
	done
#清理临时目录
	rm -rf "$temp_dir"
	if [ $success -eq 1 ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="导入成功" --text="数据导入覆盖完成！\n• 压缩包来源：$import_path\n• 已覆盖文件：\n  - ${target_names[0]}\n  - ${target_names[1]}\n  - ${target_names[2]}\n" 2>/dev/null
	else
		zenity --error --width=$WIDTH --height=$HEIGHT --title="导入部分失败" --text="部分文件导入失败，请手动检查压缩包和文件权限" 2>/dev/null
		return 1
	fi
	return 0
}
#清空所有存档数据及备份（不可逆操作，需多重确认）
function clear_all_data()
{
	local confirm1 confirm2
	local data_files=("$ITEM_FILE" "$EMPLOYEE_FILE" "$LIST_FILE")
	local data_names=("物品库存数据" "职工名单数据" "操作记录数据")
	local backup_dir="$BACKUP_DIR"
#安全警告与首次确认（明确风险）
	zenity --question --width=$WIDTH --height=$HEIGHT --title="警告：不可逆操作" --text="此操作将永久删除以下所有数据，且无法恢复！\n\n1. 核心存档数据：\n   • ${data_names[0]}（$ITEM_FILE）\n   • ${data_names[1]}（$EMPLOYEE_FILE）\n   • ${data_names[2]}（$LIST_FILE）\n\n2. 所有备份数据：\n   • 备份目录下所有文件（$backup_dir/*）\n\n请谨慎操作！" 2>/dev/null
	if [ $? -ne 0 ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="已取消" --text="清空操作已取消，返回主菜单" 2>/dev/null
		return 0
	fi
#二次确认（输入关键词验证）
	confirm1=$(zenity --entry --width=$WIDTH --height=$HEIGHT --title="二次确认" --text="为确认您的操作，请输入关键词「确认清空」（大写）：" --entry-text "" 2>/dev/null)
	if [ $? -ne 0 ] || [ "$confirm1" != "确认清空" ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="验证失败" --text="关键词输入错误或取消，清空操作终止" 2>/dev/null
		return 0
	fi
#清空核心存档数据
	local data_clear_failed=0
	echo "$(date +'%Y-%m-%d %H:%M:%S') - 开始清空核心存档数据" >&8
	for i in "${!data_files[@]}"
	do
		local file="${data_files[$i]}"
		local name="${data_names[$i]}"
		if [ -f "$file" ]
		then
#删除文件后重建空文件（避免后续操作因文件不存在报错）
			rm -f "$file" && touch "$file"
			if [ $? -eq 0 ]
			then
				echo "$(date +'%Y-%m-%d %H:%M:%S') - 清空成功：$name（$file）" >&8
			else
				echo "$(date +'%Y-%m-%d %H:%M:%S') - 清空失败：$name（$file），无写入权限" >&8
				data_clear_failed=1
			fi
		else
#文件不存在，直接创建空文件备用
			touch "$file"
			echo "$(date +'%Y-%m-%d %H:%M:%S') - 跳过清空：$name（$file）不存在，已创建空文件" >&8
		fi
	done
#清空备份目录
	local backup_clear_failed=0
	echo "$(date +'%Y-%m-%d %H:%M:%S') - 开始清空备份目录（$backup_dir）" >&8
	if [ -d "$backup_dir" ]
	then
#删除目录下所有文件（保留目录本身，避免后续备份报错）
		rm -rf "$backup_dir"/*
		if [ $? -eq 0 ]
		then
			echo "$(date +'%Y-%m-%d %H:%M:%S') - 清空成功：备份目录下所有文件已删除" >&8
		else
			echo "$(date +'%Y-%m-%d %H:%M:%S') - 清空失败：备份目录（$backup_dir）无写入权限" >&8
			backup_clear_failed=1
		fi
	else
#备份目录不存在，创建空目录备用
		mkdir -p "$backup_dir"
		echo "$(date +'%Y-%m-%d %H:%M:%S') - 跳过清空：备份目录（$backup_dir）不存在，已创建空目录" >&8
	fi
#反馈结果
	if [ $data_clear_failed -eq 0 ] && [ $backup_clear_failed -eq 0 ]
	then
		zenity --info --width=$WIDTH --height=$HEIGHT --title="清空成功" --text="所有存档数据及备份已全部清空！\n\n• 核心数据：已重置为空白文件\n• 备份数据：备份目录下所有文件已删除\n\n建议重启系统以确保数据刷新" 2>/dev/null
		echo "$(date +'%Y-%m-%d %H:%M:%S') - 清空所有数据操作完成（无失败项）" >&8
	else
		zenity --warning --width=$WIDTH --height=$HEIGHT --title="部分清空失败" --text="部分数据清空失败，请检查文件权限！\n\n失败项：\n$( [ $data_clear_failed -eq 1 ] && echo "• 核心存档数据\n" )$( [ $backup_clear_failed -eq 1 ] && echo "• 备份目录文件" )" 2>/dev/null
		echo "$(date +'%Y-%m-%d %H:%M:%S') - 清空所有数据操作完成（存在失败项）" >&8
	fi
	return 0
}
